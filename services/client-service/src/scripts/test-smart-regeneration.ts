import { config } from "dotenv";
// Load env from two levels up (scripts -> src -> root)
config({ path: "../../.env" });

import * as fs from "fs";
import { clientService } from "../services/client.service";
import { chartRepository } from "../repositories/chart.repository";
import { ChartType } from "../generated/prisma";

// Logging helper
const LOG_FILE = "verification.log";
function log(msg: string) {
  console.log(msg);
  fs.appendFileSync(LOG_FILE, msg + "\n");
}

// Clear log file
if (fs.existsSync(LOG_FILE)) fs.unlinkSync(LOG_FILE);

// Mock request metadata
const metadata = {
  userId: "00000000-0000-0000-0000-000000000000",
  ipAddress: "127.0.0.1",
  userAgent: "TestScript",
  deviceType: "desktop",
  deviceName: "TestRunner",
};

const TENANT_ID = "00000000-0000-0000-0000-000000000000";

async function testSmartRegeneration() {
  try {
    log("ðŸš€ Starting Smart Regeneration Test...");

    // 1. Create a dummy client
    log("Creating test client...");
    const clientData = {
      fullName: "Regen Test Client",
      email: `regen-test-${Date.now()}@example.com`,
      phonePrimary: `+91${Math.floor(1000000000 + Math.random() * 9000000000)}`,
      birthDate: "1990-01-01",
      birthTime: "12:00:00",
      birthLatitude: 12.9716,
      birthLongitude: 77.5946,
      birthTimezone: "Asia/Kolkata",
      birthPlace: "Bangalore, India",
    };

    const client = await clientService.createClient(TENANT_ID, clientData, metadata);
    log(`âœ… Client created: ${client.id}`);

    // 2. Create a dummy saved chart manually to simulate "old" data
    // Use a type that is hopefully not generated by default flow to avoid race condition overwrite
    await chartRepository.create(TENANT_ID, {
      clientId: client.id,
      chartType: "numerology_chaldean" as ChartType,
      system: "TEST_PERSIST", // CRITICAL: Use custom system to avoid overwrite by background "lahiri" generation
      chartData: { nums: [] }, // Dummy data
      chartName: "Old Numerology Chart",
    });
    log("âœ… Dummy chart numerology_chaldean created (simulating old data)");

    // 3. Perform Non-Trigger Update (e.g., Phone number)
    log("ðŸ”„ Updating Phone (Should NOT trigger regeneration/deletion)...");
    await clientService.updateClient(
      TENANT_ID,
      client.id,
      {
        phonePrimary: `+91${Math.floor(1000000000 + Math.random() * 9000000000)}`,
      },
      metadata,
    );

    // Verify chart still exists
    const chartsAfterPhoneUpdate = await chartRepository.findByClientId(TENANT_ID, client.id);
    const oldChartStillExists = chartsAfterPhoneUpdate.some(
      (c) => c.chartName === "Old Numerology Chart",
    );
    if (oldChartStillExists) {
      log("âœ… Validated: Charts persist after non-critical update.");
    } else {
      log("âŒ Failed: Charts were deleted after non-critical update!");
      log(
        `Found charts: ${chartsAfterPhoneUpdate.map((c) => `${c.chartType}:${c.chartName}`).join(", ")}`,
      );
      process.exit(1);
    }

    // 4. Perform Critical Update (e.g., Birth Time)
    log("ðŸ”„ Updating Birth Time (Should TRIGGER regeneration/deletion)...");
    // Note: updateClient is async but background task is fire-and-forget.
    // However, deletion is AWAITed in our new logic. So charts should be gone immediately.
    await clientService.updateClient(
      TENANT_ID,
      client.id,
      {
        birthTime: "14:30:00",
      },
      metadata,
    );

    // Verify chart is deleted
    // Wait a small moment to ensure DB transaction committed (even though await updateClient should handle the triggering)
    // But deletion is sync-awaited inside updateClient, so it should be gone.
    const chartsAfterCriticalUpdate = await chartRepository.findByClientId(TENANT_ID, client.id);

    const oldChartSurvives = chartsAfterCriticalUpdate.some(
      (c) => c.chartName === "Old Numerology Chart",
    );

    if (!oldChartSurvives) {
      log("âœ… Validated: Old charts were deleted after critical update.");
    } else {
      log("âŒ Failed: Old charts persist after critical update!");
      log(
        `Found charts: ${chartsAfterCriticalUpdate.map((c) => `${c.chartType}:${c.chartName}`).join(", ")}`,
      );
      process.exit(1);
    }

    log("ðŸŽ‰ Test Passed Successfully!");

    // Clean up
    log("Cleaning up...");
    await clientService.deleteClient(TENANT_ID, client.id, metadata);
  } catch (err) {
    log(`Test Failed: ${err}`);
    process.exit(1);
  }
}

testSmartRegeneration();
